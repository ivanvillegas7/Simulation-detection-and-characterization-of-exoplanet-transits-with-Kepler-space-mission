# -*- coding: utf-8 -*-
"""
Created on Thu May 11 14:16:15 2023

@author: Iván Villegas Pérez

The code defines several functions related to the analysis of the effect of
different parameters on the relative error in determining the transit period.
Here is a breakdown of the code:

    · The eff_flux() function generates a flux signal by combining a simulated
      transit model, sinusoidal variability, and simulated noise. It takes
      parameters such as depth, amplitude, period, phase, transit duration, and
      noise intensity, and returns the time array and the effective flux signal.

    · The effectivity() function analyzes the effect of different parameters on
      the relative error in determining the transit period. It generates
      synthetic data for various parameter combinations, applies data analysis
      techniques, and calculates the relative error. The function then plots
      the relative error against the chosen parameter. The specific plots
      generated depend on the value of i. There are six different cases, each
      corresponding to a different parameter. The plots are saved as PDF files
      in the "Plots/Effectivity" directory.

The get_effectivity() function calls the effectivity() function for different
values of i to analyze the effect of different parameters on the relative error
in determining the transit period. It loops through the values 0 to 5 and calls
the effectivity() function for each value.

Overall, this code appears to be part of a larger project that involves
simulating transit signals, analyzing data, and studying the effect of different
parameters on the accuracy of determining transit periods.
"""

import numpy as np
import matplotlib.pyplot as plt
from typing import List

import analize
import remove
import simulate
import conf_level

def eff_flux(depth: float, amplitude: float, period: float, phase: float,\
             t_per: float, mult: float):
    """
    This function generates a flux signal by combining a simulated transit model,
    sinusoidal variability, and simulated noise to check how effective the used
    method is.

    Parameters:
    - depth (float): Depth of the transit.
    - amplitude (float): Amplitude of the sinusoidal variability.
    - period (float): Period of the sinusoidal variability.
    - phase (float): Phase of the sinusoidal variability.
    - t_per (float): Duration of the transit.
    - mult (float): Multiplicative factor for the simulated noise.
    
    Returns:
    - time (1D array): Time array.
    - flux (1D array): Effective flux signal generated by combining the
                       transit model, sinusoidal variability, and noise.
    """
    t_duration: float = t_per/5 #0.5
    t0: float = t_duration/2 #0.25
    t_start: float = 0
    t_end: float = 50

    time: np.array(float) = np.linspace(t_start, t_end, 100000)

    # Generate transit model
    flux_p: np.array(float)
    flux_p = simulate.generate_parabolic_transit(t_per, t0, t_duration, depth,\
                                                 time)

    # Simulate noise
    A: float
    A = 0.3

    df: float
    df = 3

    nc: float
    nc = 1

    loc: float
    loc = 0

    scale: float
    scale = 1

    params: List[float]

    params = [A, df, nc, loc, scale]

    noise: np.array(float)
    noise = simulate.simulate_noise(len(flux_p), params)

    # Generate sinusoidal variability
    offset: float = 500

    variability: np.array(float)
    variability = simulate.sinusoidal_variability(time, amplitude, period,\
                                                  phase*np.pi, offset)

    # Combine flux with variability and noise
    flux: np.array(float)
    flux = flux_p + variability + mult*noise

    return(time, flux)

def effectivity(i: int):
    
    """
    This function analyzes the effect of different parameters on the relative
    error in determining the transit period. It generates synthetic data for
    various parameter combinations, applies data analysis techniques, and
    calculates the relative error between the known transit period and the
    determined period. The function then plots the relative error against the
    chosen parameter.

    Parameters:
    - i (int): Index to select the parameter combination to analyze.
    
    Returns:
    - None
    
    The function generates plots of the relative error against the chosen
    parameter and saves them as PDF files. The specific plots generated depend
    on the value of i:

    - i=0: Relative error vs. transit depth.
    - i=1: Relative error vs. variability amplitude.
    - i=2: Relative error vs. variability period.
    - i=3: Relative error vs. variability phase.
    - i=4: Relative error vs. transit period.
    - i=5: Relative error vs. noise intensity.
    
    The plots are saved in the "Plots/Effectivity" directory.
    """

    if i==0:

        depth: np.array(float) = np.linspace(0, 5, 1000)

        amplitude: np.array(float) = 2*np.ones(1000)

        period: float = 7

        phase: float = 1

        t_per: np.array(float) = 2.5*np.ones(1000)
        
        noise: float = 1

    elif i==1:

        depth: np.array(float) = 5*np.ones(100)

        amplitude: np.array(float) = np.linspace(0, 5, 100)

        period: float = 7

        phase: float = 1

        t_per: np.array(float) = 2.5*np.ones(100)
        
        noise: float = 1

    elif i==2:

        depth: np.array(float) = 5*np.ones(1000)

        amplitude: np.array(float) = 2*np.ones(1000)

        period: np.array(float) = np.linspace(0.01, 15, 1000)

        phase: float = 1

        t_per: np.array(float) = 2.5*np.ones(1000)
        
        noise: float = 1

    elif i==3:

        depth: np.array(float) = 5*np.ones(100)

        amplitude: np.array(float) = 2*np.ones(100)

        period: float = 7

        phase: np.array(float) = np.linspace(0, 2, 100)

        t_per: np.array(float) = 2.5*np.ones(100)
        
        noise: float = 1

    elif i==4:

        depth: np.array(float) = 5*np.ones(1000)

        amplitude: np.array(float) = 2*np.ones(1000)

        period: float = 7

        phase: float = 1

        t_per: np.array(float) = np.linspace(0.01, 50, 1000)
        
        noise: float = 1
        
    elif i==5:
        
        depth: np.array(float) = 5*np.ones(1000)

        amplitude: np.array(float) = 2*np.ones(1000)

        period: float = 7

        phase: float = 1
        
        t_per: np.array(float) = 2.5*np.ones(1000)
        
        noise: np.array(float) = np.linspace(0.1,10, 1000)

    err_mean: List[float] = []
    
    err_bar: List[np.array(float)] = []

    for j in range(len(t_per)):

        err: List[float] = []

        for _ in range(100):

            time: np.array(float)
            flux: np.array(float)

            if i==0:

                time, flux = eff_flux(depth[j], amplitude[j], period, phase,\
                                      t_per[j], noise)

            elif i==1:

                time, flux = eff_flux(depth[j], amplitude[j], period, phase,\
                                      t_per[j], noise)

            elif i==2:

                time, flux = eff_flux(depth[j], amplitude[j], period[j], phase,\
                                      t_per[j], noise)

            elif i==3:

                time, flux = eff_flux(depth[j], amplitude[j], period, phase[j],\
                                      t_per[j], noise)

            elif i==4:

                time, flux = eff_flux(depth[j], amplitude[j], period, phase,\
                                      t_per[j], noise)
                
            elif i==5:
                
                time, flux = eff_flux(depth[j], amplitude[j], period, phase,\
                                      t_per[j], noise[j])

            filtered_flux: np.array(float)
            filtered_flux = analize.median_filter(time, flux, 101)

            best_fit_params: np.array(float)
            best_fit_params = analize.best_fit(time, filtered_flux)

            flux_nv: np.array(float)
            flux_nv = remove.discard_variability(time, filtered_flux,\
                                                 best_fit_params)

            result: float = analize.get_period(flux_nv, 1/(time[1]-time[0]))

            err.append(np.abs(t_per[j]-result)/t_per[j])

        err_mean.append(np.mean(err))
        
        err_bar.append(conf_level.confidence_limits(err, 0.68))
        
        if i==2:
        
            print(period[j])

    plt.figure()
    plt.ylabel('Relative error on the transit period determination')
    plt.grid(True)

    if i==0:

        plt.plot(depth, err_mean, marker='.')
        for k in range(len(err_bar)):
            plt.axvline(depth[k], err_bar[k][0], err_bar[k][1])
        plt.xlabel("Transit's depth [u]")
        plt.title("Relative error against transit's depth")
        plt.savefig('../Plots/Effectivity/REvsTD.pdf')

    elif i==1:

        plt.plot(amplitude, err_mean, marker='.')
        for k in range(len(err_bar)):
            plt.axvline(amplitude[k], err_bar[k][0], err_bar[k][1])
        plt.xlabel('Variability amplitude [u]')
        plt.title('Relative error against variability amplitude')
        plt.savefig('../Plots/Effectivity/REvsVA.pdf')

    elif i==2:

        plt.plot(period, err_mean, marker='.')
        for k in range(len(err_bar)):
            plt.axvline(period[k], err_bar[k][0], err_bar[k][1])
        plt.xlabel('Variability period [days]')
        plt.title('Relative error against variability period')
        plt.savefig('../Plots/Effectivity/REvsVP.pdf')

    elif i==3:

        plt.plot(phase, err_mean, marker='.')
        for k in range(len(err_bar)):
            plt.axvline(phase[k], err_bar[k][0], err_bar[k][1])
        plt.xlabel(r'Variability phase [$\pi$ rad]')
        plt.title('Relative error against variability phase')
        plt.savefig('../Plots/Effectivity/REvsVPh.pdf')

    elif i==4:

        plt.plot(t_per, err_mean, marker='.')
        for k in range(len(err_bar)):
            plt.axvline(t_per[k], err_bar[k][0], err_bar[k][1])
        plt.xlabel('Transit period [days]')
        plt.title('Relative error against transit period')
        plt.savefig('../Plots/Effectivity/REvsTP.pdf')
        
    elif i==5:

        plt.plot(noise, err_mean, marker='.')
        for k in range(len(err_bar)):
            plt.axvline(noise[k], err_bar[k][0], err_bar[k][1])
        plt.xlabel('Noise intensity')
        plt.title('Relative error against noise intensity')
        plt.savefig('../Plots/Effectivity/REvsNI.pdf')
        
    import updates

def get_effectivity():
    """
    The function calls the effectivity(i) function for different values of i to
    analyze the effect of different parameters on the relative error in
    determining the transit period. It loops through the values 0 to 5 and calls
    the effectivity() function for each value.

    Parameters:
    - None
    
    Returns:
    - None
    """
    for i in range(6):

        effectivity(i)

#%%
effectivity(0)
#%%
effectivity(2)
#%%
effectivity(4)
#%%
effectivity(5)